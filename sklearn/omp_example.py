import numpy as np
from numpy.linalg import norm, pinv
from sklearn.linear_model import orthogonal_mp

def random_dict(m, n):
    """Create an m-by-n random dictionary.

    The entries are i.i.d. gaussian.

    Parameters
    ----------
    m : number of rows
    n : number of columns

    Return
    ------
    D : The dictionary
    """
    D = np.random.randn(m, n)
    D /= np.sqrt(np.sum((D ** 2), axis=0))

    return D

def get_sparse_x(n, s):
    """Create an s-sparse vector of length n.

    The support is selected uniformly at random. The amplitudes on the support
    are i.i.d. gaussian.
    
    Parameters
    ----------
    n : length of the vector
    s : number of non-zero entries

    """
    i = np.arange(0,n)
    np.random.shuffle(i)
    support = i[:s]

    x = np.zeros((n, 1))
    x[np.ix_(support), 0] = np.random.randn(s)

    return x
    

def single_experiment(n, m, s, use_naive=False):
    """Run a single experiment.

    The experiment consist on recovering an s-sparse signal of length n from m
    measurements using OMP. The original signal is generated by get_sparse_x

    Parameters
    ----------
    n : length of the signal
    m : number of measurements
    s : sparsity of the signal
    use_naive : if true, use naive implementation of OMP, use scikit.learn
       implementation otherwise. Default to False
       
    Return
    ------
    error: The ell_2 norm of the difference between the original and the
       recovered signal
    """
    D = random_dict(m, n)
    x = get_sparse_x(n, s)
    y = np.dot(D, x)
    if use_naive:
        x_hat = omp_naive(D, y)
    else:
        x_hat = orthogonal_mp(D, y, s)
    x_hat.resize(n, 1)
    error = norm(x - x_hat)
    return error

def omp_naive(D, y):
    """ Recover x using naive implementation of OMP.

    Parameter
    ---------
    D: Dictionary
    y: Measurement

    Return
    ------
    x_hat : Estimate of x
    """
    n = D.shape[1]
    r = y.copy()
    k = 1
    Delta = []
    while norm(r) > 1e-3:
        h = np.abs(np.dot(D.T, r))
        Delta.append(np.argmax(h))
        alpha = np.dot(pinv(D[:,Delta]), y)
        r = y - np.dot(D[:, Delta], alpha)
        k += 1

    x_hat = np.zeros(n)
    x_hat[Delta] = alpha

    return x_hat
                   
def experiment_1(n, m, s, n_trials=100):
    """Compare the scikit.learn version of OMP versus a naive implementation.

    Parameters
    ----------
    n : ambient dimension
    m : number of measuremenst
    s : sparsity level
    n_trials : number of trials. Default to 100
    """
    n_skit = 0
    n_naive = 0
    for i in range(n_trials):
        if single_experiment(n, m, s) < 1e-4:
            n_skit += 1
        if single_experiment(n, m, s, use_naive=True) < 1e-4:
            n_naive += 1
            
    p_skit =  float(n_skit) / n_trials
    p_naive = float(n_naive) / n_trials

    print('n: %d, m: %d, s: %d -> p_skit = %.2f p_naive = %.2f'
          % (n, m, s, p_skit, p_naive))
        

if __name__ == '__main__':
    print ('Comparing scikit.learn version of OMP versus naive '
           'implementation')
    n = 256 # Ambient dimension
    s = 10 # Sparsity
    for m in range(30, 200, 20): # number of measurements
        experiment_1(n, m, s, n_trials=500)

