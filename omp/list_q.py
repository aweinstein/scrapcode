import sys

import numpy as np
from numpy.linalg import norm, pinv
from sklearn.linear_model import orthogonal_mp
from scipy import linalg

def random_dict(m, n):
    """Create an m-by-n random dictionary.

    The entries are i.i.d. gaussian.

    Parameters
    ----------
    m : number of rows
    n : number of columns

    Return
    ------
    D : The dictionary
    """
    D = np.random.randn(m, n)
    D /= np.sqrt(np.sum((D ** 2), axis=0))

    return D

def get_sparse_x(n, s):
    """Create an s-sparse vector of length n.

    The support is selected uniformly at random. The amplitudes on the support
    are i.i.d. gaussian.
    
    Parameters
    ----------
    n : length of the vector
    s : number of non-zero entries

    """
    i = np.arange(0,n)
    np.random.shuffle(i)
    support = i[:s]

    x = np.zeros((n, 1))
    #x[np.ix_(support), 0] = np.random.randn(s)
    x[np.ix_(support), 0] = (np.random.rand(s) + 0.5) * (np.random.randn(s) > 0).astype('int')

    return x
    

def single_experiment(n, m, s, methods=['naive']):
    """Run a single experiment.

    The experiment consist on recovering an s-sparse signal of length n from m
    measurements using OMP. The original signal is generated by get_sparse_x

    Parameters
    ----------
    n : length of the signal
    m : number of measurements
    s : sparsity of the signal
    methods : list of methods to try. Each method must be in ['naive', 'scikit', 'vlad']
       implementation otherwise. Default to False
       
    Return
    ------
    errors: List with he ell_2 norm of the difference between the original and the
       recovered signal for each method in methods.
    """
    D = random_dict(m, n)
    x = get_sparse_x(n, s)
    y = np.dot(D, x)
    errors = []
    for method in methods:
        if method == 'naive':
            x_hat = omp_naive(D, y)
        elif method == 'scikit':
            x_hat = orthogonal_mp(D, y, s)
        elif method == 'vlad':
            x_hat = omp_vlad(D, y, s)
        else:
            print 'Unknown method'
            sys.exit(1)
        x_hat.resize(n, 1)
        errors.append(norm(x - x_hat))
    return errors

def omp_vlad(X, y, n_nonzero_coefs, eps=None):
    residual = y
    idx = []
    if eps == None:
        stopping_condition = lambda: len(idx) == n_nonzero_coefs
    else:
        stopping_condition = lambda: np.inner(residual, residual) <= eps
    while not stopping_condition():
        #lam = np.abs(np.dot(residual, X)).argmax()
        lam = np.abs(np.dot(X.T, residual)).argmax()
        idx.append(lam)
        gamma, _, _, _ = linalg.lstsq(X[:, idx], y)
        residual = y - np.dot(X[:, idx], gamma)

    n = X.shape[1]
    gamma_hat = np.zeros(n)
    gamma_hat[idx] = gamma
    return gamma_hat
    #return x_hat
    #return gamma, idx



def omp_naive(D, y):
    """ Recover x using naive implementation of OMP.

    Parameter
    ---------
    D: Dictionary
    y: Measurement

    Return
    ------
    x_hat : Estimate of x
    """
    n = D.shape[1]
    r = y.copy()
    k = 1
    Delta = []
    while norm(r) > 1e-3:
        h = np.abs(np.dot(D.T, r))
        Delta.append(np.argmax(h))
        alpha = np.dot(pinv(D[:,Delta]), y)
        r = y - np.dot(D[:, Delta], alpha)
        k += 1

    x_hat = np.zeros(n)
    x_hat[Delta] = alpha

    return x_hat
                   
def experiment_1(n, m, s, n_trials=100):
    """Compare the scikit.learn version of OMP versus a naive implementation.

    Parameters
    ----------
    n : ambient dimension
    m : number of measuremenst
    s : sparsity level
    n_trials : number of trials. Default to 100
    """
    n_skit = 0
    n_naive = 0
    for i in range(n_trials):
        if single_experiment(n, m, s) < 1e-4:
            n_skit += 1
        if single_experiment(n, m, s, use_naive=True) < 1e-4:
            n_naive += 1
            
    p_skit =  float(n_skit) / n_trials
    p_naive = float(n_naive) / n_trials

    print('n: %d, m: %d, s: %d -> p_skit = %.2f p_naive = %.2f'
          % (n, m, s, p_skit, p_naive))
        

if __name__ == '__main__x':
    print ('Comparing scikit.learn version of OMP versus naive '
           'implementation')
    n = 128 # Ambient dimension
    s = 10 # Sparsity
    m = 40
    #for m in range(30, 100, 20): # number of measurements
    #experiment_1(n, m, s, n_trials=100)

    ## while 1:
    ##     errors = single_experiment(n, 50, 10, ['scikit', 'naive', 'vlad'])
    ##     err_scikit, err_naive, err_vlad = errors
    ##     if err_scikit > 1 and err_naive < 1e-3:
    ##         print 
    
    print errs



if __name__ == '__main__':
    n = 128
    s = 10
    m = 40
    D = random_dict(m, n)
    k = 0
    while 1:

        x = get_sparse_x(n, s)
        y = np.dot(D, x)
        x_naive = omp_naive(D, y)
        x_scikit = orthogonal_mp(D, y, s)
        error_naive = norm(x - x_naive.reshape(n,1))
        error_scikit = norm(x - x_scikit.reshape(n,1))

        k += 1
        if error_naive < 1e-3 and error_scikit > 1:
            print x
            break

    print k

    import matplotlib.pylab as plt

    nr = np.arange(0, n)
    plt.subplot(311)
    plt.stem(nr, x)
    plt.subplot(312)
    plt.stem(nr, x_naive)
    plt.subplot(313)
    plt.stem(nr, x_scikit)
    plt.show()
